/*
 * generated by Xtext 2.30.0
 */
package org.sdu.dsl4ifc.tests

import com.google.inject.Inject
import java.io.File
import java.io.FileOutputStream
import java.io.PrintStream
import java.util.ArrayList
import java.util.HashMap
import java.util.Map
import lca.epdConnectors.EcoPlatformConnector
import org.eclipse.emf.common.util.URI
import org.eclipse.emf.ecore.resource.Resource
import org.eclipse.xtext.resource.XtextResourceSet
import org.eclipse.xtext.testing.InjectWith
import org.eclipse.xtext.testing.extensions.InjectionExtension
import org.eclipse.xtext.util.StringInputStream
import org.junit.jupiter.api.Test
import org.junit.jupiter.api.^extension.ExtendWith
import org.sdu.dsl4ifc.generator.IfcFileInformation
import org.sdu.dsl4ifc.generator.SustainLangGenerator

@ExtendWith(InjectionExtension)
@InjectWith(SustainLangInjectorProvider)
class PerformanceTest {
	
	@Inject
	SustainLangGenerator generator
	
	PrintStream log
	String csvPath = "./ifc-files-data.csv";
	
	Map<String, IfcFileInformation> fileInformation = new HashMap
	
	var int fileCount = 0; var int fileTotal = 0;
	var int repCount = 0;  final int repTotal = 1;
	var int testCount = 0; val int testTotal = 16;
	var int typeCount = 0; val int typeTotal = 3;

	
	@Test
	def void test() {
		
		var ifcFolderPath = "C:\\Users\\Andreas\\Downloads\\ifc\\Sorted";
        var folderFile = new File(ifcFolderPath);
        var ifcFiles = folderFile.listFiles().filter[file | file.name.endsWith(".ifc")];
        
        println("Warming up EcoPlatform...")
        warmUpEcoPlatform();
        println("Done!")
        
        fileTotal = ifcFiles.length;
		
		log = new PrintStream(new FileOutputStream(csvPath));
		try {
	        
	        log.println("File Name, File Size [byte], File Entities Count, File Relations Count, File Properties Count, IFC Source Program, Cold Response Time [ms], Warm Response Time [ms], Cold Query ID, Warm Query ID, Test Name, IfcType (Data Volume), Warm vs. Cold Response Time Diff. [ms]");
			
			for (file : ifcFiles) {
				
				fileCount++;
				repCount = 0;
				
				val path = file.absolutePath
				println(path)
				
				val info = generator.getIfcFileInformation(path)
				fileInformation.put(path, info)
				
				for (var i = 0; i < repTotal; i++) {
					repCount++;
					testCount = 0;
					runTests(path)
				}
			}
		
		} finally {
			log.close
		}
		
	}
	
	protected def void warmUpEcoPlatform() {
		val ifcPath = "C:/Users/Andreas/Downloads/ifc/warm-up/warm-up.ifc"
        val resourceSet = new XtextResourceSet();
        val resource = createResource(ifcPath, QueryEnum.LcaUsingEcoPlatform, resourceSet, "IfcWall");
		generator.runTest(resource)
	}
	
	protected def void runTests(String path) {
		testCount++;
		runTest(path, TestEnum.IdentifierNameChanged)
		testCount++;
		runTest(path, TestEnum.AddedToSelect)
		testCount++;
		runTest(path, TestEnum.FilterExpressionChanged)
		testCount++;
		runTest(path, TestEnum.LcaChanged)
		testCount++;
		runTest(path, TestEnum.FilterAdded)
		testCount++;
		runTest(path, TestEnum.FilterRemoved)
		testCount++;
		runTest(path, TestEnum.LcaAdded)
		testCount++;
		runTest(path, TestEnum.LcaRemoved)
		
		testCount++;
		runTest(path, TestEnum.AutomaticAreaAdded)
		testCount++;
		runTest(path, TestEnum.AutomaticAreaRemoved)
		testCount++;
		runTest(path, TestEnum.AutomaticMaterialMappingAdded)
		testCount++;
		runTest(path, TestEnum.AutomaticMaterialMappingRemoved)
		testCount++;
		runTest(path, TestEnum.EpdSourceToEcoPlatform)
		testCount++;
		runTest(path, TestEnum.EpdSourceToBR18)
		testCount++;
		runTest(path, TestEnum.GroupByAdded)
		testCount++;
		runTest(path, TestEnum.GroupByRemoved)
	}
	
	def runTest(String ifcPath, TestEnum test) {
		
		println('''Running Test [«test»]''')
		
		switch (test) {
			case IdentifierNameChanged: {
				runAllVolumeQueries(ifcPath, QueryEnum.Identifier1, QueryEnum.Identifier2, "Identifier Name Changed")
			}
			case AddedToSelect: {
				runAllVolumeQueries(ifcPath, QueryEnum.SelectOneProperty, QueryEnum.SelectTwoProperties, "Property Added to Select")
			}
			case FilterExpressionChanged: {
				runAllVolumeQueries(ifcPath, QueryEnum.Filter1, QueryEnum.Filter2, "Filter Expression Changed")
			}
			case LcaChanged: {
				runAllVolumeQueries(ifcPath, QueryEnum.LCA1, QueryEnum.LCA2, "LCA Changed")
			}
			case FilterAdded: {
				runAllVolumeQueries(ifcPath, QueryEnum.NoFilter, QueryEnum.Filter1, "Filter Added")
			}
			case FilterRemoved: {
				runAllVolumeQueries(ifcPath, QueryEnum.Filter1, QueryEnum.NoFilter, "Filter Removed")
			}
			case LcaAdded: {
				runAllVolumeQueries(ifcPath, QueryEnum.NoLCA, QueryEnum.LCA1, "LCA Added")
			}
			case LcaRemoved: {
				runAllVolumeQueries(ifcPath, QueryEnum.LCA1, QueryEnum.NoLCA, "LCA Removed")
			}
			
			case AutomaticAreaAdded: {
				runAllVolumeQueries(ifcPath, QueryEnum.LCA1, QueryEnum.LcaWithAutomaticArea, "Automatic Area Added")
			}
	
			case AutomaticAreaRemoved: {
				runAllVolumeQueries(ifcPath, QueryEnum.LcaWithAutomaticArea, QueryEnum.LCA1, "Automatic Area Removed")
			}
			
			case AutomaticMaterialMappingAdded: {
				runAllVolumeQueries(ifcPath, QueryEnum.LCA1, QueryEnum.LcaWithAutomaticMaterialMapping, "Automatic Material Mapping Added")
			}
	
			case AutomaticMaterialMappingRemoved: {
				runAllVolumeQueries(ifcPath, QueryEnum.LcaWithAutomaticMaterialMapping, QueryEnum.LCA1, "Automatic Material Mapping Removed")
			}
	
			case EpdSourceToEcoPlatform: {
				runAllVolumeQueries(ifcPath, QueryEnum.LCA1, QueryEnum.LcaUsingEcoPlatform, "EPD Source to EcoPlatform")
			}
	
			case EpdSourceToBR18: {
				runAllVolumeQueries(ifcPath, QueryEnum.LcaUsingEcoPlatform, QueryEnum.LCA1, "EPD Source to BR18")
			}
	
			case GroupByAdded: {
				runAllVolumeQueries(ifcPath, QueryEnum.NoFilter, QueryEnum.GroupBy, "Group By Added")
			}
	
			case GroupByRemoved: {
				runAllVolumeQueries(ifcPath, QueryEnum.GroupBy, QueryEnum.NoFilter, "Group By Removed")
			}
		
			default: {
				throw new Exception("Test is not found...")
			}
		}
	}
	
	String[] ifcTypes = #[
		"IfcMaterial", 
		"IfcWall", 
		"IfcRoot"
	];
	
	def runAllVolumeQueries(String ifcPath, QueryEnum coldQuery, QueryEnum warmQuery, String testName) {
		typeCount = 0;
		
		for (ifcType : ifcTypes) {
			typeCount++;
			
			generator.clearCache
			EcoPlatformConnector.envProdMap.clear
			runWarmAndColdQuery(ifcPath, coldQuery, warmQuery, testName, ifcType)
		}
	}
	
	def runWarmAndColdQuery(String ifcPath, QueryEnum coldQuery, QueryEnum warmQuery, String testName, String ifcType) {
		// Set up a resource set
		val resourceSet = new XtextResourceSet();
		
		val coldResource = createResource(ifcPath, coldQuery, resourceSet, ifcType);
		val warmResource = createResource(ifcPath, warmQuery, resourceSet, ifcType);
		
		// Cold
		var time = System.currentTimeMillis
		generator.runTest(coldResource);
		val coldResponseTime = System.currentTimeMillis - time
		println('''Cold response time: «coldResponseTime» ms.''')
		
		// Warm
		time = System.currentTimeMillis
		generator.runTest(warmResource);
		val warmResponseTime = System.currentTimeMillis - time
		println('''Warm response time: «warmResponseTime» ms.''')
		
		appendResult(coldResponseTime, warmResponseTime, ifcPath, coldQuery, warmQuery, testName, ifcType)
	}
	
	def appendResult(long coldResponseTime, long warmResponseTime, String ifcPath, QueryEnum coldQuery, QueryEnum warmQuery, String testName, String ifcType) {
		val info = fileInformation.get(ifcPath)
		
		// 0. file name
		// 1. file size [byte]
		// 2. file entities count
		// 3. file relations count
		// 4. file properties count
		// 5. ifc source program
		// 6. cold response time [ms]
		// 7. warm response time [ms]
		// 8. cold query id
		// 9. warm query id
		// 10. test name
		// 11. IfcType (Data Volume)
		// 12. warm vs. cold response time diff.
		
        val cells = new ArrayList<String>;
		
		// 0: File name
        cells.add(info.fileName);

        // 1: File size (byte)
        cells.add(info.fileSize+"");

        // 2: Entities count
        cells.add(info.entitiesCount+"");

        // 3: Relations count
        cells.add(info.relationsCount+"");

        // 4: Properties count
        cells.add(info.propertiesCount+"");

        // 5: Source program
        cells.add(info.sourceProgram);
        
        // 6: Cold Response time
        cells.add(coldResponseTime+"");
        
        // 7: Warm Response time
        cells.add(warmResponseTime+"");
        
        // 8: Cold Query id
        cells.add(coldQuery+"");
        
        // 9: Warm Query id
        cells.add(warmQuery+"");
        
        // 10: Test Name
        cells.add(testName);
        
        // 11: IfcType (Data Volume)
        cells.add(ifcType);
        
        // 12: warm vs. cold response time diff. [ms]
        cells.add(warmResponseTime - coldResponseTime + "");
        
        val row = String.join(",", cells);
        log.println(row)
        
        println('''File[«fileCount»/«fileTotal»], Rep[«repCount»/«repTotal»], Test[«testCount»/«testTotal»], Type[«typeCount»/«typeTotal»]''');
	}
	
	def Resource createResource(String ifcPath, QueryEnum queryEnum, XtextResourceSet resourceSet, String ifcType) {
		val uriString = '''«queryEnum»_«ifcPath.substring(2)».slang'''
		val resource = resourceSet.createResource(URI.createURI(uriString));
		
		// Add content to the resource
		val query = getQuery(ifcPath.replace("\\", "\\\\"), queryEnum, ifcType);
		//println('''Got query: '«query»''')
				
		resource.load(new StringInputStream(query), null);
		
		return resource
	}
	
	def String getQuery(String ifcPath, QueryEnum queryEnum, String ifcType) {
		
		switch (queryEnum) {
			case Identifier1: {
				return '''
				SOURCE "«ifcPath»"
				GET «ifcType» x WHERE x.name <> ""
				OUTPUT TABLE x COLUMNS[stepnumber, name]
				'''
			}
			case Identifier2: {
				return '''
				SOURCE "«ifcPath»"
				GET «ifcType» y WHERE x.name <> ""
				OUTPUT TABLE y COLUMNS[stepnumber, name]
				'''
			}
			case SelectOneProperty: {
				return '''
				SOURCE "«ifcPath»"
				GET «ifcType» x
				OUTPUT TABLE x COLUMNS[stepnumber]
				'''
			}
			case SelectTwoProperties: {
				return '''
				SOURCE "«ifcPath»"
				GET «ifcType» x
				OUTPUT TABLE x COLUMNS[stepnumber, name]
				'''
			}
			case Filter1: {
				return '''
				SOURCE "«ifcPath»"
				GET «ifcType» x WHERE x.name <> ""
				OUTPUT TABLE x COLUMNS[stepnumber, name]
				'''
			}
			case Filter2: {
				return '''
				SOURCE "«ifcPath»"
				GET «ifcType» x WHERE x.name = "ifc-name"
				OUTPUT TABLE x COLUMNS[stepnumber, name]
				'''
			}
			case LCA1: {
				return '''
				SOURCE "«ifcPath»"
				GET «ifcType» x
				CALCULATE LCA (lcaResult <- SUMMARY, elms <- ELEMENTS) FOR x (
					AREA 50
					HEATEDAREA 5
					B6 10
					EPD BR18
					MATERIAL MAPPING (
						"Letklinkerblok, Massiv" -> "​​#B1339"
					)
				)
				OUTPUT TABLE elms COLUMNS[result];
				'''
			}
			case LCA2: {
				return '''
				SOURCE "«ifcPath»"
				GET «ifcType» x
				CALCULATE LCA (lcaResult <- SUMMARY, elms <- ELEMENTS) FOR x (
					AREA 500
					HEATEDAREA 50
					B6 100
					EPD BR18
					MATERIAL MAPPING (
						"Concrete, Cast In Situ" -> "#G0242"
					)
				)
				OUTPUT TABLE elms COLUMNS[result];
				'''
			}
			case NoFilter: {
				return '''
				SOURCE "«ifcPath»"
				GET «ifcType» x
				OUTPUT TABLE x COLUMNS[stepnumber, name]
				'''
			}
			case NoLCA: {
				return '''
				SOURCE "«ifcPath»"
				GET «ifcType» x
				OUTPUT TABLE x COLUMNS[stepnumber]
				'''
			}
			
			case LcaWithAutomaticArea: {
				return '''
				SOURCE "«ifcPath»"
				GET «ifcType» x
				CALCULATE LCA (lcaResult <- SUMMARY, elms <- ELEMENTS) FOR x (
					AREA AUTO
					HEATEDAREA 5
					B6 10
					EPD BR18
					MATERIAL MAPPING (
						"Letklinkerblok, Massiv" -> "​​#B1339"
					)
				)
				OUTPUT TABLE elms COLUMNS[result];
				'''
			}
			
			case LcaWithAutomaticMaterialMapping: {
				return '''
				SOURCE "«ifcPath»"
				GET «ifcType» x
				CALCULATE LCA (lcaResult <- SUMMARY, elms <- ELEMENTS) FOR x (
					AREA 50
					HEATEDAREA 5
					B6 10
					EPD BR18
					MATERIAL MAPPING AUTO
				)
				OUTPUT TABLE elms COLUMNS[result];
				'''
			}
			
			case LcaUsingEcoPlatform: {
				return '''
				SOURCE "«ifcPath»"
				GET «ifcType» x
				CALCULATE LCA (lcaResult <- SUMMARY, elms <- ELEMENTS) FOR x (
					AREA 50
					HEATEDAREA 5
					B6 10
					EPD EcoPlatform
					MATERIAL MAPPING (
						"Letklinkerblok, Massiv" -> "​​#B1339"
					)
				)
				OUTPUT TABLE elms COLUMNS[result];
				'''
			}
			
			case GroupBy: {
				return '''
				SOURCE "«ifcPath»"
				GET «ifcType» x
				GROUP x BY ifctype
				OUTPUT TABLE x COLUMNS[SUM(stepnumber), ifctype]
				'''
			}
			
			default: throw new Exception("Query not found: " + queryEnum)
		}
	}
}

enum QueryEnum {
	Identifier1,
	Identifier2,
	SelectOneProperty,
	SelectTwoProperties,
	Filter1,
	Filter2,
	LCA1,
	LCA2,
	NoFilter,
	NoLCA,
	LcaWithAutomaticArea,
	LcaWithAutomaticMaterialMapping,
	LcaUsingEcoPlatform,
	GroupBy
}

enum TestEnum {
	IdentifierNameChanged,
	AddedToSelect,
	FilterExpressionChanged,
	LcaChanged,
	FilterAdded,
	FilterRemoved,
	LcaAdded,
	LcaRemoved,
	AutomaticAreaAdded,
	AutomaticAreaRemoved,
	AutomaticMaterialMappingAdded,
	AutomaticMaterialMappingRemoved,
	EpdSourceToEcoPlatform,
	EpdSourceToBR18,
	GroupByAdded,
	GroupByRemoved
}
