/*
 * generated by Xtext 2.30.0
 */
package org.sdu.dsl4ifc.tests

import com.google.inject.Inject
import java.io.File
import java.io.FileOutputStream
import java.io.PrintStream
import java.util.ArrayList
import java.util.HashMap
import java.util.Map
import org.eclipse.emf.common.util.URI
import org.eclipse.emf.ecore.resource.Resource
import org.eclipse.xtext.resource.XtextResourceSet
import org.eclipse.xtext.testing.InjectWith
import org.eclipse.xtext.testing.extensions.InjectionExtension
import org.eclipse.xtext.util.StringInputStream
import org.junit.jupiter.api.Test
import org.junit.jupiter.api.^extension.ExtendWith
import org.sdu.dsl4ifc.generator.IfcFileInformation
import org.sdu.dsl4ifc.generator.SustainLangGenerator
import org.eclipse.emf.ecore.resource.impl.ResourceSetImpl
import org.eclipse.emf.ecore.xmi.impl.XMIResourceFactoryImpl

@ExtendWith(InjectionExtension)
@InjectWith(SustainLangInjectorProvider)
class PerformanceTest {
	
	
	@Inject
	SustainLangGenerator generator
	
	PrintStream log
	String csvPath = "./performance-test_" + System.currentTimeMillis + ".csv";
	
	Map<String, IfcFileInformation> fileInformation = new HashMap
	
	final int reps = 10;
	
	@Test
	def void performanceTest() {
		
		Resource.Factory.Registry.INSTANCE.getExtensionToFactoryMap().put("xmi", new XMIResourceFactoryImpl());
		
		var ifcFolderPath = "C:\\Users\\Andreas\\Downloads\\ifc";
        var folderFile = new File(ifcFolderPath);
        var ifcFiles = folderFile.listFiles().filter[file | file.name.endsWith(".ifc")];
		
		log = new PrintStream(new FileOutputStream(csvPath));
		try {
	        
	        log.println("File Name, File Size [byte], File Entities Count, File Relations Count, File Properties Count, IFC Source Program, Cold Response Time [ms], Warm Response Time [ms], Cold Query ID, Warm Query ID, Test Name, IfcType (Data Volume), Warm vs. Cold Response Time Diff. [ms]");
			
			for (file : ifcFiles) {
				val path = file.absolutePath
				println(path)
				
				val info = generator.getIfcFileInformation(path)
				fileInformation.put(path, info)
				
				for (var i = 0; i < reps; i++) {
					runTests(file)
				}
			}
		
		} finally {
			log.close
		}
		
	}
	
	protected def void runTests(File ifcFile) {
		runTest(ifcFile, TestEnum.IdentifierNameChanged)
		runTest(ifcFile, TestEnum.AddedToSelect)
		runTest(ifcFile, TestEnum.FilterExpressionChanged)
		runTest(ifcFile, TestEnum.LcaChanged)
		runTest(ifcFile, TestEnum.FilterAdded)
		runTest(ifcFile, TestEnum.FilterRemoved)
		runTest(ifcFile, TestEnum.LcaAdded)
		runTest(ifcFile, TestEnum.LcaRemoved)
	}
	
	def runTest(File ifcFile, TestEnum test) {
		
		println('''Running Test [«test»]''')
		
		switch (test) {
			case IdentifierNameChanged: {
				runAllVolumeQueries(ifcFile, QueryEnum.Identifier1, QueryEnum.Identifier2, "Identifier Name Changed")
			}
			case AddedToSelect: {
				runAllVolumeQueries(ifcFile, QueryEnum.SelectOneProperty, QueryEnum.SelectTwoProperties, "Property Added to Select")
			}
			case FilterExpressionChanged: {
				runAllVolumeQueries(ifcFile, QueryEnum.Filter1, QueryEnum.Filter2, "Filter Expression Changed")
			}
			case LcaChanged: {
				runAllVolumeQueries(ifcFile, QueryEnum.LCA1, QueryEnum.LCA2, "LCA Changed")
			}
			case FilterAdded: {
				runAllVolumeQueries(ifcFile, QueryEnum.NoFilter, QueryEnum.Filter1, "Filter Added")
			}
			case FilterRemoved: {
				runAllVolumeQueries(ifcFile, QueryEnum.Filter1, QueryEnum.NoFilter, "Filter Removed")
			}
			case LcaAdded: {
				runAllVolumeQueries(ifcFile, QueryEnum.NoLCA, QueryEnum.LCA1, "LCA Added")
			}
			case LcaRemoved: {
				runAllVolumeQueries(ifcFile, QueryEnum.LCA1, QueryEnum.NoLCA, "LCA Removed")
			}
		
			default: {
				throw new Exception("Test is not found...")
			}
		}
	}
	
	String[] ifcTypes = #[
		"IfcMaterial", 
		"IfcWall", 
		"IfcRoot"
	];
	
	def runAllVolumeQueries(File ifcFile, QueryEnum coldQuery, QueryEnum warmQuery, String testName) {
		
		for (ifcType : ifcTypes) {
			generator.clearCache
			runWarmAndColdQuery(ifcFile, coldQuery, warmQuery, testName, ifcType)
		}
	}
	
	def runWarmAndColdQuery(File ifcFile, QueryEnum coldQuery, QueryEnum warmQuery, String testName, String ifcType) {
		// Set up a resource set
		val resourceSet = new XtextResourceSet();
		
		
		val coldResource = createResource(ifcFile, coldQuery, resourceSet, ifcType);
		val warmResource = createResource(ifcFile, warmQuery, resourceSet, ifcType);
		
		// Cold
		var time = System.currentTimeMillis
		generator.runTest(coldResource);
		val coldResponseTime = System.currentTimeMillis - time
		println('''Cold response time: «coldResponseTime» ms.''')
		
		// Warm
		time = System.currentTimeMillis
		generator.runTest(warmResource);
		val warmResponseTime = System.currentTimeMillis - time
		println('''Warm response time: «warmResponseTime» ms.''')
		
		appendResult(coldResponseTime, warmResponseTime, ifcFile.absolutePath, coldQuery, warmQuery, testName, ifcType)
	}
	
	def appendResult(long coldResponseTime, long warmResponseTime, String ifcPath, QueryEnum coldQuery, QueryEnum warmQuery, String testName, String ifcType) {
		val info = fileInformation.get(ifcPath)
		
		// 0. file name
		// 1. file size [byte]
		// 2. file entities count
		// 3. file relations count
		// 4. file properties count
		// 5. ifc source program
		// 6. cold response time [ms]
		// 7. warm response time [ms]
		// 8. cold query id
		// 9. warm query id
		// 10. test name
		// 11. IfcType (Data Volume)
		// 12. warm vs. cold response time diff.
		
        val cells = new ArrayList<String>;
		
		// 0: File name
        cells.add(info.fileName);

        // 1: File size (byte)
        cells.add(info.fileSize+"");

        // 2: Entities count
        cells.add(info.entitiesCount+"");

        // 3: Relations count
        cells.add(info.relationsCount+"");

        // 4: Properties count
        cells.add(info.propertiesCount+"");

        // 5: Source program
        cells.add(info.sourceProgram);
        
        // 6: Cold Response time
        cells.add(coldResponseTime+"");
        
        // 7: Warm Response time
        cells.add(warmResponseTime+"");
        
        // 8: Cold Query id
        cells.add(coldQuery+"");
        
        // 9: Warm Query id
        cells.add(warmQuery+"");
        
        // 10: Test Name
        cells.add(testName);
        
        // 11: IfcType (Data Volume)
        cells.add(ifcType);
        
        // 12: warm vs. cold response time diff. [ms]
        cells.add(warmResponseTime - coldResponseTime + "");
        
        val row = String.join(", ", cells);
        log.println(row)
	}
	
	def Resource createResource(File ifcFile, QueryEnum queryEnum, ResourceSetImpl resourceSet, String ifcType) {		
		val resource = resourceSet.createResource(URI.createURI('''«queryEnum»_«ifcFile.name».slang'''));
		
		// Add content to the resource
		val query = getQuery(ifcFile, queryEnum, ifcType);
		println('''Got query: '«query»''')
				
		resource.load(new StringInputStream(query), null);
		
		return resource
	}
	
	def String getQuery(File ifcFile, QueryEnum queryEnum, String ifcType) {
		val ifcPath = ifcFile.absolutePath.replace("\\", "\\\\")
		
		switch (queryEnum) {
			case Identifier1: {
				return '''
				SOURCE MODEL "«ifcPath»"
				SELECT x.stepnumber, x.name
				FROM «ifcType» x
				FILTER x WHERE x.name <> ""
				'''
			}
			case Identifier2: {
				return '''
				SOURCE MODEL "«ifcPath»"
				SELECT y.stepnumber, y.name
				FROM «ifcType» y
				FILTER y WHERE x.name <> ""
				'''
			}
			case SelectOneProperty: {
				return '''
				SOURCE MODEL "«ifcPath»"
				SELECT x.stepnumber
				FROM «ifcType» x
				'''
			}
			case SelectTwoProperties: {
				return '''
				SOURCE MODEL "«ifcPath»"
				SELECT x.stepnumber, x.name
				FROM «ifcType» x
				'''
			}
			case Filter1: {
				return '''
				SOURCE MODEL "«ifcPath»"
				SELECT x.stepnumber, x.name
				FROM «ifcType» x
				FILTER x WHERE x.name <> ""
				'''
			}
			case Filter2: {
				return '''
				SOURCE MODEL "«ifcPath»"
				SELECT x.stepnumber, x.name
				FROM «ifcType» x
				FILTER x WHERE x.name = "ifc-name"
				'''
			}
			case LCA1: {
				return '''
				SOURCE MODEL "«ifcPath»"
				SELECT elements.result
				FROM «ifcType» x
				DO LCA(
					AREA 5
					AREAHEAT 5
					B6 10
					SOURCE x
					MATDEF (
						"Letklinkerblok, Massiv" -> "​​#B1339"
					) 
				) sum, elements
				'''
			}
			case LCA2: {
				return '''
				SOURCE MODEL "«ifcPath»"
				SELECT elements.result
				FROM «ifcType» x
				DO LCA(
					AREA 500
					AREAHEAT 500
					B6 100
					SOURCE x
					MATDEF (
						"Concrete, Cast In Situ" -> "#G0242"
					) 
				) sum, elements
				'''
			}
			case NoFilter: {
				return '''
				SOURCE MODEL "«ifcPath»"
				SELECT x.stepnumber, x.name
				FROM «ifcType» x
				'''
			}
			case NoLCA: {
				return '''
				SOURCE MODEL "«ifcPath»"
				SELECT x.stepnumber
				FROM «ifcType» x
				'''
			}
			
			default: throw new Exception("Query not found")
		}
	}
}

enum QueryEnum {
	Identifier1,
	Identifier2,
	SelectOneProperty,
	SelectTwoProperties,
	Filter1,
	Filter2,
	LCA1,
	LCA2,
	NoFilter,
	NoLCA
}

enum TestEnum {
	IdentifierNameChanged,
	AddedToSelect,
	FilterExpressionChanged,
	LcaChanged,
	FilterAdded,
	FilterRemoved,
	LcaAdded,
	LcaRemoved
}
