/*
 * generated by Xtext 2.30.0
 */
package org.sdu.dsl4ifc.generator

import com.apstex.ifc2x3toolbox.ifc2x3.IfcWall
import org.eclipse.emf.ecore.resource.Resource
import org.eclipse.ui.console.ConsolePlugin
import org.eclipse.ui.console.MessageConsole
import org.eclipse.ui.console.MessageConsoleStream
import org.eclipse.xtext.generator.AbstractGenerator
import org.eclipse.xtext.generator.IFileSystemAccess2
import org.eclipse.xtext.generator.IGeneratorContext
import org.sdu.dsl4ifc.generator.depedencyGraph.blocks.Ifc2x3ParserBlock
import org.sdu.dsl4ifc.generator.depedencyGraph.blocks.SourceBlock
import org.sdu.dsl4ifc.generator.depedencyGraph.blocks.TypeBlock
import org.sdu.dsl4ifc.sustainLang.Statement
import org.sdu.dsl4ifc.generator.depedencyGraph.blocks.FilterBlock
import com.apstex.ifc2x3toolbox.ifc2x3.IfcDoor
import java.util.List
import org.sdu.dsl4ifc.generator.conditional.impls.EntityValueEqualsVariableValueOperation
import com.apstex.ifc2x3toolbox.ifc2x3.IfcRoot

/**
 * Generates code from your model files on save.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#code-generation
 */
class SustainLangGenerator extends AbstractGenerator {
	
	public static MessageConsoleStream consoleOut = null;

	override void doGenerate(Resource resource, IFileSystemAccess2 fsa, IGeneratorContext context) {
		
		val myConsole = findConsole("SusLang");
		consoleOut = myConsole.newMessageStream();
		consoleOut.println("SusLang Console");
		
		val statements = resource.allContents.filter(Statement);
		
		val statement = statements.head
		val sourceCommand = statement.source
		
		
		val sourceBlock = new SourceBlock("Source", sourceCommand.path, resource)
		val parserBlock = new Ifc2x3ParserBlock("Parser 2x3")
		val wallTypeBlock = new TypeBlock("Type1", "w", IfcWall);
		val doorTypeBlock = new TypeBlock("Type2", "d", IfcRoot);
		
		parserBlock.AddInput(sourceBlock)
		wallTypeBlock.AddInput(parserBlock)
		doorTypeBlock.AddInput(parserBlock)
		
		filterBlockVariableComparisonTest(wallTypeBlock, doorTypeBlock)
		
		//val walls = wallTypeBlock.output
		
		//val extractor = new ParameterValueExtractor<IfcWall, String>("name")
		
		//val list = walls.map[w | extractor.getParameterValue(w)].toList
		//list.forEach[name | consoleOut.println(name)]
	}
	
	def void filterBlockVariableComparisonTest(TypeBlock<?> wallTypeBlock, TypeBlock<?> doorTypeBlock) {
		val extr1 = new ParameterValueExtractor<IfcWall, String>("name");
		
		val valEq1 = new EntityValueEqualsVariableValueOperation("d", extr1, extr1);
		val filterBlock = new FilterBlock<IfcWall>("F1", "w", valEq1);
		
		filterBlock.AddInput(wallTypeBlock);
		filterBlock.AddInput(doorTypeBlock);
		
		val output = filterBlock.output.toList
		if (output.empty) {
			consoleOut.println("No objects returned")
		} else {
			output.forEach[w | consoleOut.println(w.name.decodedValue)]
		}
		
	}
		
	def MessageConsole findConsole(String name) {
	    val plugin = ConsolePlugin.getDefault()
	    val conMan = plugin.getConsoleManager()
	    val existing = conMan.getConsoles()
	    for (console : existing) {
	        if (name.equals(console.getName())) {
	            return console as MessageConsole
	        }
	    }
	    // no console found, so create a new one
	    val myConsole = new MessageConsole(name, null)
	    val consoles = #[myConsole];
	    conMan.addConsoles(consoles);
	    return myConsole;
	}
	
	
}
